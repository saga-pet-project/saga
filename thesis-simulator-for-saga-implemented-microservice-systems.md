# Перевод магистерской десертации: Simulator for Saga Implemented Microservice Systems
Andre´ Martins Esgalhado —  Thesis to obtain the Master of Science Degree in Computer Science and Engineering

## Введение

Архитектура микросервисов используется для проектирования большого количества программных систем благодаря своим преимуществам в плане масштабируемости и небольших команд разработчиков. Однако она не лишена и своих сложностей, таких как сложность разработки и управление согласованностью данных. Первая связана со сложностью промежуточного программного обеспечения, например, Kafka, используемого для реализации микросервисных систем. Вторая связана с распределенными транзакциями, которые должны быть скоординированы для поддержки функциональных возможностей микросервисной системы, что является следствием теоремы CAP (Consistency Availability Partition), которая утверждает, что существует компромисс между согласованностью и доступностью. Рассматриваемые вместе, эти две проблемы приводят к тому, что проблемы с согласованностью данных можно выявить только на поздних этапах процесса разработки. Таким образом, может случиться так, что только после значительных усилий по разработке команда осознает, что архитектура микросервисов на самом деле не окупается, например, из-за проблем и сложностей, связанных с координацией распределенных транзакций.


Следовательно, стоит сдвинуть влево (shift left) сложные аспекты, связанные с проектированием микросервисных систем, в процессе разработки. В частности, решить проблему сложности, связанной с реализацией распределенных транзакций в микросервисной системе.

## Саги как решение

Саги (Sagas) — это транзакционная модель, связанная с координацией распределенных транзакций в микросервисных системах, что является текущей инженерной практикой. Следуя этой модели, разработчики должны решать проблемы, возникающие из-за отсутствия изоляции вследствие существования промежуточных состояний, такие как потерянные обновления (lost updates) и грязные чтения (dirty reads). Такие решения, как семантические блокировки (semantic locks), при которых транзакции помечают промежуточные состояния для других транзакций, требуют индивидуального проектирования, которое может быть подвержено ошибкам.

В этой диссертации мы предлагаем симулятор микросервисов саг, который моделирует микросервисную систему в соответствии с подходом предметно-ориентированного проектирования (Domain-Driven Design, DDD). Он содержит минимальный набор элементов, необходимых для описания бизнес-логики микросервисной системы и координации между микросервисами, что позволяет тестировать взаимодействия в централизованной среде. Таким образом, происходит сдвиг влево анализа и исправления координации системы, до фактической реализации в более дорогостоящем и проблемном контексте распределенной среды. Более того, отладка в детерминированной среде обеспечивает более быстрый цикл обратной связи для проектирования бизнес-логики микросервисной системы. Используя симулятор, архитекторы программного обеспечения могут оценить целесообразность архитектуры микросервисов для решаемой проблемы или даже решить, что некоторые части системы должны быть реализованы с использованием транзакционной модели ACID (Atomicity Consistency Isolation Durability), поскольку некоторые утверждают, что не вся система должна следовать архитектуре микросервисов.

Симулятор оценивается на основе канонического набора координаций распределенных транзакций в микросервисных системах, и с помощью симулятора была реализована крупная микросервисная система с богатой бизнес-логикой.

## Проблемы разработки микросервисов

Разработка микросервисных систем требует сложного проектирования бизнес-логики приложения из-за необходимости обеспечения его согласованности в контексте распределенного исполнения. С другой стороны, существует несколько архитектурных стилей для реализации микросервисных архитектур. Как описывает Крис Ричардсон, этот тип архитектуры определяется как набор слабосвязанных сервисов, которые развертываются независимо. Некоторые из наиболее распространенных проблем при разработке микросервисов включают обеспечение согласованности, поддержание связи между сервисами и отладку в распределенной среде. Кроме того, разработка микросервисной системы сложна и требует использования сложных технологий.

Несмотря на различные попытки упростить разработку микросервисов, особенно когда речь идет о фреймворках, помогающих создавать микросервисные системы, существует пробел в предоставлении независимой от технологий, удобной среды для архитекторов, чтобы они могли экспериментировать с архитектурным проектированием и получать обратную связь через короткие циклы.


## Предлагаемое решение

Для решения некоторых из этих проблем был разработан Симулятор Транзакционных Причинно-Согласованных Микросервисов (Transactional Causal Consistent Microservices Simulator, TCCMS). Этот симулятор расширяет концепцию агрегата, позволяя его реализацию в модели транзакционной причинной согласованности (Transactional Causal Consistency), которая предотвращает некоторые типы аномалий, возникающих из-за отсутствия изоляции. Хотя TCC предлагает более строгую модель согласованности, большинство микросервисных систем используют итоговую согласованность (eventual consistency) в качестве модели согласованности по двум причинам: это простая модель, которая в некоторых случаях может обеспечить достаточные гарантии, учитывая семантику приложения; отсутствует стандартное промежуточное программное обеспечение, доступное для более сложных моделей, которое можно использовать в производстве. В таких сценариях итоговая согласованность, поддерживаемая моделью Saga, может быть лучшей альтернативой. По этим причинам предлагаемая работа является расширением этого симулятора, который будет поддерживать паттерн Saga, реализующий модель Saga для архитектуры микросервисов. Еще одна причина для расширения симулятора для поддержки паттерна Saga заключается в том, что это широко распространенный подход, который поможет разработчикам принимать более обоснованные решения и имитировать реальные системы.


# Введение

Эта глава содержит объяснения по некоторым темам, имеющим отношение к данной дипломной работе (Thesis): Архитектура Саг (Saga Architecture), Предметно-ориентированное проектирование (Domain-Driven Design, DDD), сравнение между Сагами и Транзакционной причинной согласованностью (Transactional Causal Consistency), состояние Симулятора транзакционной причинной согласованности и проблемы, связанные с этими концепциями.

## Проблема

Предметно-ориентированное проектирование (DDD) принимается в качестве подхода к проектированию доменной модели для микросервисных систем. Вместо большой, взаимосвязанной доменной модели, микросервис разделен на набор агрегатов (aggregates), которые являются атомарными единицами изменения. Следовательно, доступ к агрегату атомарен. Кроме того, агрегаты определяют единицу согласованности через набор инвариантов (invariants), которые должны сохраняться агрегатом. Однако возможны несогласованности между агрегатами, не описанные в инвариантах, которые должны быть в конечном итоге разрешены.

В дополнение к концепции агрегата, предметно-ориентированное проектирование определяет зависимости между командами, которые разрабатывают агрегаты, так что они могут иметь определенный уровень независимости. Следовательно, отношение "восходящий-нисходящий" (upstream-downstream) между двумя командами означает, что нисходящая (downstream) команда зависит от восходящей (upstream) команды; нисходящая команда осведомлена о восходящих агрегатах, но обратное не происходит. Это соответствует существованию основных моделей (core models), от которых зависят другие модели, и это в некоторой степени связано со стилем многоуровневой архитектуры (layered architecture style), где нижние уровни независимы от верхних.

### Пример Агрегатов и Инвариантов

Листинг 2.1 представляет три агрегата: CourseExecution (ВыполнениеКурса), Quiz (Тест/Викторина) и Tournament (Турнир), каждый из которых имеет корневую сущность (root entity) (с уникальным идентификатором) и набор других сущностей. Агрегаты CourseExecution и Quiz являются основным доменом (core domain), и команды, которые их разрабатывают, не должны зависеть от модели Tournament. Фактически, Tournament использует их. У Tournament есть два инварианта (строки 20–25):

Время начала турнира должно быть раньше времени окончания.

Если создатель турнира также является участником, у них должно быть одинаковое имя.

### Соответствие DDD и Микросервисной Архитектуры

При отображении этих концепций на микросервисную архитектуру мы можем связать микросервис с каждым агрегатом, поскольку он является атомарной единицей изменения. Отношение "восходящий-нисходящий" между микросервисами соответствует:

Интерфейсу прикладного программирования (API) сервисов, предлагаемых восходящим агрегатом, который используется нисходящими агрегатами.

Набору событий (events), публикуемых восходящим агрегатом, на которые могут подписываться нисходящие агрегаты.

Первое соответствует зависимости команды, ответственной за нисходящий агрегат, от API, предоставляемого восходящим агрегатом. Второе поддерживает независимость восходящей команды от нисходящих команд; всякий раз, когда происходят изменения в восходящем агрегате, им нужно только опубликовать события; если нисходящая команда заинтересована, ее обязанность — подписаться на них и выполнить необходимые изменения.

Рассматривая вышеупомянутые агрегаты, агрегаты Course и Quiz являются микросервисами, которые предлагают API сервисов, которые может вызывать микросервис, связанный с агрегатом Tournament. Например, когда студент записывается на турнир, микросервис Tournament вызывает сервис запросов (query service) в микросервисе Course для получения информации о студенте. И когда турнир создается, микросервис Tournament вызывает микросервис Quiz для создания теста турнира. С другой стороны, если студент меняет имя, микросервис Course публикует событие, на которое подписывается микросервис Tournament, потому что команда, разрабатывающая Course, не знает о микросервисе Tournament.

### Функциональности и Координация Микросервисов

Мы можем рассмотреть две функциональности, которые дополняют этот пример:

1. UpdateStudentName (ОбновитьИмяСтудента)
Эта функциональность обращается к агрегату Course, генерируя событие, на которое подписывается нисходящий агрегат Tournament, поскольку это функциональность Course, который является восходящим. После обработки сгенерированного события имена создателя и участника в агрегате Tournament соблюдают свои инварианты.

2. AddParticipant (ДобавитьУчастника)
Эта функциональность читает из агрегата Course для получения информации о студенте, а затем записывает в агрегат Tournament, добавляя студента в список участников. Этот процесс возможен, потому что агрегат Tournament является нисходящим, и это функциональность Tournament. Это изображено в Листинге 2.2.

### Распределенные Транзакции и Несогласованные Состояния

Поведение микросервисной системы определяется ее функциональностями, которые могут соответствовать координации одного или нескольких микросервисов. Когда координируются транзакции нескольких микросервисов, возникает распределенная транзакция, которая может привести к несогласованным состояниям.

Например, после изменения имени студента в микросервисе CourseExecution система может быть несогласованной, если этот студент записан на Tournament. В конечном итоге, событие обновления имени будет обработано, и согласованность восстановлена.

Более сложное взаимодействие между транзакциями, которое может вызвать несогласованные состояния, происходит при определенном чередовании функциональности записи студента и функциональности обновления имени студента, когда записываемый студент является создателем турнира. Функциональность записи студента имеет две локальные транзакции:

Чтение студента в микросервисе CourseExecution.

Регистрация участника в микросервисе Tournament.

Когда функциональность обновления имени происходит после чтения студента (включая обработку его события обновления в Tournament) и до регистрации участника, это приведет к тому, что у создателя будет обновленное имя, а у участника — исходное имя, что нарушает один инвариант.

Другая ситуация возникает, когда Tournament создается, что занимает несколько шагов, и если выполняется запрос для получения всех турниров, в результат попадет не полностью сконструированный турнир.

### Модель Транзакций Саги (Sagas)

Для решения этих типов проблем была предложена модель транзакций Саги (Sagas), где из-за отсутствия изоляции возможно, что транзакции выполняют компенсирующие транзакции (compensating transactions) для восстановления согласованного состояния в случае отката (abort). В настоящее время определено несколько шаблонов для реализации модели транзакций Саги, таких как семантические блокировки (semantic locks), которые локальные транзакции записывают в агрегаты, находящиеся в промежуточном состоянии.

В упомянутом случае запроса на получение всех турниров, микросервис, реализующий запрос, может отфильтровать турниры, которые не полностью сконструированы. Обратите внимание, что то, что делать с семантическими блокировками, зависит от функциональности; если у турнира есть другая семантическая блокировка, указывающая, что он изменяется, он может быть не отфильтрован. Следовательно, определение поведения Саг выполняется на индивидуальной основе, что увеличивает сложность бизнес-логики и делает важным его рассмотрение на ранних этапах процесса разработки, потому что это определяет поведение приложения.

### Требования к Симулятору

Синтезируя, следующие аспекты должны быть учтены симулятором для микросервисных систем, разработанных в соответствии с предметно-ориентированным проектированием и использующих модель транзакций Саги:

Атомарные Агрегаты (Atomic Aggregates): В соответствии с моделью агрегата, агрегат является атомарной единицей для изменения. Таким образом, симулятор должен гарантировать, что в любой момент агрегат не может быть изменен двумя транзакциями, избегая проблемы потерянного обновления (lost update). Например, две функциональности, которые записывают студента, обе читают один и тот же турнир, а затем обновляют его. Последняя, которая записывает агрегат турнира, не должна перезаписывать изменения, сделанные первой.

Инварианты Агрегата (Aggregate Invariants): Также необходимо, чтобы инварианты сохранялись на уровне агрегата при каждом атомарном изменении. Например, после того как студент записался на турнир, необходимо проверить инвариант, связанный с именами создателя и участников.

Отношения Агрегатов "Восходящий-Нисходящий" (Upstream-Downstream Aggregate Relations): Обработка событий является асинхронной, что вызывает несколько ситуаций:

Сама по себе в системе присутствует согласованность в конечном счете (eventual consistency), о которой функциональности должны быть осведомлены. Например, после обновления имени студента, функциональность, которая обращается к турниру, может не получить самое актуальное имя, и если это важно с точки зрения бизнес-логики функциональности, она должна запросить CourseExecution.

Более сложной является возможность постоянной несогласованности из-за порядка выполнения событий, как описано выше, когда событие обновления имени обрабатывается до регистрации студента.

Промежуточные Состояния Агрегата (Aggregate Intermediate States): Когда функциональность изменила агрегат, но еще не завершилась, это состояние может быть прочитано другими функциональностями, и, если первая функциональность откатывается, возникает проблема грязного чтения (dirty read). Для решения этой проблемы необходимо поддерживать семантические блокировки для обозначения промежуточных состояний. Следовательно, в симуляторе, при доступе к агрегату с семантической блокировкой, функциональность сама решает (это зависит от ее бизнес-логики), откатиться и повторить, прочитать агрегат или проигнорировать семантическую блокировку и продолжить обработку. Например, когда турнир обновляется, последний шаг — обновить его тест. Если обновление теста завершается неудачей, обновление турнира необходимо отменить, и, чтобы информировать другие функциональности о том, что турнир находится в промежуточном состоянии, к турниру добавляется семантическая блокировка.

## Семантика

### Архитектура Saga

Как объясняется в книге "Microservices Patterns" [9], одна из самых сложных задач при работе с микросервисной архитектурой — это реализация транзакций, затрагивающих несколько сервисов. В такой архитектуре проблема возникает, когда транзакции влияют на данные в нескольких сервисах, в отличие от случая, когда они происходят в одном сервисе, где мы все еще можем использовать ACID (Atomicity, Consistency, Isolation, Durability — Атомарность, Согласованность, Изолированность, Долговечность) транзакции.

Решение этой проблемы связано с использованием Sagas [8]. Ричардсон (Richardson) предлагает Saga как "управляемую сообщениями последовательность локальных транзакций для поддержания согласованности данных" [9]. Недостаток использования Sagas заключается в том, что они не обладают свойством изоляции ACID-транзакций, и, следовательно, приложение должно использовать некоторые контрмеры для устранения этого недостатка изоляции.

Нил Форд (Neal Ford) и соавторы [18] идут еще дальше Ричардсона и расширяют представление о том, что может существовать множество паттернов Транзакционных Saga (Transactional Saga patterns), созданных из различных комбинаций ключевых аспектов (dimensions): коммуникация, согласованность и координация.

Коммуникация: Режим или метод обмена информацией между различными элементами или этапами Sagas, который может быть синхронным или асинхронным.

Согласованность: Свойство, касающееся корректности и целостности данных системы, в которой несколько операций выполняются параллельно или распределенно. Она может быть итоговой (eventual) или атомарной (atomic).

Координация: Подход, используемый для управления и контроля потока выполнения распределенной транзакции в Saga. Она может быть оркестрированной (orchestrated) или хореографической (choreographed).

### Предметно-ориентированное проектирование (Domain-Driven Design)

В мире микросервисной архитектуры Предметно-ориентированное проектирование (Domain-Driven Design, DDD) является фундаментальным подходом, используемым в процессе разработки. Это не только архитектурный подход, но и философия проектирования, которая сосредоточена на моделировании предметной области (домена) приложения. Это особенно полезно в контексте микросервисов, поскольку может помочь лучше определить и структурировать каждый сервис и его границы в рамках приложения. Принципы, используемые в DDD, часто основаны на таких концепциях, как агрегаты (aggregates), события (events), функциональные возможности (functionalities), сущности (entities), объекты-значения (value objects), репозитории (repositories), ограниченные контексты (bounded contexts) и отношения "upstream-downstream" (вышестоящий-нижестоящий).

Агрегаты представляют собой границы транзакционной согласованности и диктуют правила для модификаций данных внутри домена, что определяет согласованность агрегата. Это единица атомарного изменения.

Сущность и Объекты-значения — это элементы, составляющие агрегаты; они содержат специфическое для предметной области поведение и данные.

События действуют как триггеры для функциональных возможностей, связанных с отношениями "upstream-downstream" между агрегатами. Они помогают оркестрировать взаимодействия между различными компонентами системы, способствуя поддержанию когерентности и согласованности.

Репозитории отвечают за управление жизненным циклом агрегатов, включая управление их персистентностью.

Ограниченные контексты группируют агрегаты, которые являются зоной ответственности команды разработчиков.

Отношения "Upstream-downstream" между ограниченными контекстами определяют зависимости разработки между командами, ответственными за ограниченные контексты. Команда-downstream (нижестоящая) осведомлена о команде-upstream (вышестоящей), и обратное неверно. Когда происходит изменение в агрегате в ограниченном контексте-upstream, публикуется событие, на которое могут подписаться агрегаты в ограниченных контекстах-downstream.

Функциональная возможность (Functionality) определяет координацию взаимодействия между агрегатами посредством вызова их сервисов. Агрегаты также взаимодействуют друг с другом через паттерн "публикация-подписка" (publish-subscribe). Функциональная возможность ассоциирована с агрегатом, известным как главный агрегат (main aggregate) функциональной возможности. Она вызывает сервисы в своих главных агрегатах и всех агрегатах, которые являются upstream, однако она не может вызывать сервисы в агрегатах-downstream, потому что команда, разрабатывающая функциональную возможность, не осведомлена об агрегатах-downstream. Следовательно, когда сервис агрегата изменяет агрегат, он может публиковать события, на которые подписываются агрегаты-downstream. При получении события агрегаты-downstream могут инициировать другую функциональную возможность для его обработки.

### Sagas против Транзакционной Причинной Согласованности (Transactional Causal Consistency)

Хотя Sagas являются одним из наиболее устоявшихся подходов, когда речь идет о поддержании согласованности данных в микросервисных архитектурах, в последнее время были предложены различные альтернативы для устранения некоторых их проблем. Например, Транзакционная Причинная Согласованность (Transactional Causal Consistency, TCC) [19] — это еще один способ решения этой проблемы. В отличие от Sagas, TCC направлена на обеспечение согласованности, основанной на причинно-следственных связях между транзакциями. Это может быть актуально в сценариях, где более сильная согласованность и изоляция важнее гибкости, предоставляемой Sagas. Фактически, высокий уровень сложности TCC не стоит усилий для ряда приложений, особенно тех, которым не требуются сильные уровни согласованности. Кроме того, в настоящее время нет коммерческих реализаций TCC, а исследовательские реализации работают поверх хранилищ типа "ключ-значение". В итоге, на уровне бизнес-логики Sagas децентрализуют управление транзакциями, отдают приоритет итоговой согласованности, остаются более подходящими для сложных рабочих процессов и являются отраслевым стандартом.

В следующих разделах мы рассмотрим, как Sagas и TCC связаны с разработкой микросервисных систем.

### Симулятор Микросервисов с Транзакционной Причинной Согласованностью

Этот симулятор был ранее разработан для тестирования и экспериментирования с проектированием микросервисов, построенных на концепции агрегата. Агрегаты специфицируются в соответствии с концепциями инвариантов, которые определяют их бизнес-логику. Кроме того, симулятор поддерживал определение поведения TCC, связанного с взаимодействиями между агрегатами [20].

Симулятор состоял из трех модулей, как показано на Рисунке 2.1. Это был доменный модуль (красный), который содержал концепции агрегата и события, используемые для определения микросервиса. Затем был причинный модуль (зеленый), где инфраструктура для поведения TCC была реализована с использованием паттерна "единица работы" (unit of work) [21]. Наконец, был модуль "quizzes" (тесты), который соответствовал примеру микросервисной системы, реализованной с использованием симулятора. Этот модуль содержал два подмодуля: один, связанный с бизнес-логикой микросервисов, независимой от конкретной транзакционной модели, которая расширяет домен (синий), и другой, который расширяет транзакционно-независимую бизнес-логику поведением TCC (оранжевый). Подробное объяснение этих модулей можно найти в статье, представленной к публикации [22].

Рисунок 2.2 иллюстрирует, как симулятор может быть использован для реализации микросервиса. Диаграмма показывает классы, которые необходимо было расширить, и методы, которые необходимо было переопределить. Во-первых, была определена бизнес-логика микросервиса (синий). Затем было добавлено поведение TCC (оранжевый). Обратите внимание, как доменные элементы (красный) и инфраструктура TCC (зеленый) использовались при расширении.

Некоторые из его ключевых архитектурных элементов:

Агрегаты: Агрегаты в симуляторе спроектированы так, чтобы быть независимыми от какой-либо конкретной транзакционной модели. Это обеспечивает универсальную основу, где основные бизнес-сущности и правила определяются без первоначальной привязки к конкретной транзакционной модели.

UnitOfWork: Паттерн "единица работы" в симуляторе служит механизмом для координации сложных транзакций, особенно тех, которые охватывают несколько агрегатов или сервисов.

Функциональная возможность (Functionality): Определяет координацию сервисов агрегатов, используя UnitOfWork для добавления транзакционного поведения к их выполнению.

Этот подход позволяет симулятору поддерживать модульную и гибкую архитектуру, где основная бизнес-логика, инкапсулированная в агрегатах и управляемая событиями, может быть определена независимо, а затем интегрирована с конкретной транзакционной моделью. Стоит отметить, что симулятор мог помочь разработчикам экспериментировать с этими различными архитектурами и помочь им имитировать влияние реализации в соответствии с их потребностями и выбором. Чтобы лучше понять, как работал симулятор, ниже описан пример, показывающий, как были реализованы случаи в Листингах 2.1 и 2.2. Во-первых, определен агрегат Tournament и его соответствующие инварианты, как показано в Листинге 2.3. Идентификатор Tournament берется от расширения Aggregate, где он генерируется. Затем invariantStartTimeBeforeEndTime(), строки 8-10, представляет первый инвариант. После этого необходимо переопределить метод verifyInvariants(). То же самое делается для метода getEventSubscriptions(), строки 20-25. Оба метода являются абстрактными методами, определенными в Aggregate. Следует отметить, что, хотя здесь демонстрируется только один случай, разработчики должны включать все соответствующие случаи для инвариантов.

Далее агрегат Tournament расширяется классом CausalTournament, реализующим причинный агрегат. Три метода, которые необходимо расширить, — getMutableFields(), строки 9-12, getIntentions(), строки 14-20, и mergeFields(), строки 22-37, — обеспечивают причинную семантику агрегата. Листинг 2.4 показывает определение класса.

Функциональные возможности выполняются над агрегатами, специфичными для транзакционной модели, в данном случае TCC. Листинг 2.5 показывает пример того, как функциональная возможность addParticipant из Листинга 2.2 была реализована в симуляторе. Сначала создается unitOfWork, строки 2-3. Затем извлекаются необходимые данные, в данном случае турнир и пользователь (участник), строки 3-9. После этого создается новый TournamentParticipant. Затем вызывается сервис, и участник добавляется в турнир, строка 11. Все это делается в контексте созданного unitOfWork. Наконец, сервис unitOfWork фиксирует изменения, которые зависят от транзакционной модели.

Функциональная возможность вызывает сервисы агрегатов. Сервис addParticipant агрегата Tournament показан в Листинге 2.6.

Можно заметить, что реализация сервиса сильно связана с транзакционной моделью, она создает экземпляры CausalTournament, строка 10. Также обратите внимание, что метод aggregateLoadAndRegisterRead() также зависит от транзакционной модели, но он уже инкапсулирован внутри UnitOfWork.

Некоторые проблемы, выявленные в состоянии симулятора до начала работы над данной диссертацией, включают:

Закодированные функциональные возможности и сервисы: Реализация жестко интегрировала конкретные функциональные возможности и сервисы с транзакционной моделью (TCC), что ограничивало гибкость симулятора для экспериментирования с различными архитектурными стилями, такими как паттерн Saga. Это видно в реализации функциональной возможности, которая использовала конкретный UnitOfWork, реализующий TCC, и в порядке вызовов. Это видно в Листингах 2.5 и 2.6, где CausalUnitOfWork создается и используется, соответственно. Также создается определенный класс Causal агрегата. Это показано в Листинге 2.6, где турнир создается из CausalTournament. Обратите внимание, что если необходимо добавить компенсирующие транзакции, реализацию функциональной возможности необходимо изменить. Кроме того, сервисы зависят от UnitOfWork и агрегатов, специфичных для транзакций.

Ограниченные паттерны коммуникации: Дизайн симулятора предполагал синхронные паттерны коммуникации, что видно в Листинге 2.5, где код напрямую вызывает методы сервиса в определенной последовательности. Это может быть неприемлемо для всех микросервисных архитектур, особенно тех, которые используют асинхронные методы.

Эти проблемы могут затруднить использование симулятора в большем количестве контекстов и ограничить его эффективное применение в разнообразных архитектурных контекстах и практических приложениях. Следующие разделы будут исследовать и обсуждать эти проблемы более подробно, а также потенциальные решения.

Технологии для реализации и симуляторы микросервисных систем
Существуют промежуточные технологии (middleware) для реализации микросервисных систем, такие как Spring Cloud 
1
 . Однако при их использовании невозможно провести предварительное проектирование функциональности системы и ее бизнес-логики, поскольку разработчик быстро погружается в технологическую сложность.

С другой стороны, существуют фреймворки, которые поддерживают проектирование микросервисных приложений на более высоком уровне, например Eventuate Tram [23], Temporal [24] и SagaMAS [25]. Хотя эти фреймворки предоставляют высокоуровневые конструкции, такие как оркестровка сервисов и компенсирующие транзакции, они явно не предоставляют конструкций для предметно-ориентированного проектирования (Domain-Driven Design, DDD) и все еще сосредоточены на разработке продуктивной системы, что вызывает те же проблемы технологической сложности.

Существует несколько симуляторов для распределенных систем, которые сосредоточены на моделировании сети и анализе ее характеристик [26–29] или на описании распределенных алгоритмов [30–32], но они не фокусируются на архитектурном стиле микросервисов и не решают такие проблемы, как управление транзакциями.

Недавно был предложен новый набор симуляторов для микросервисных систем. Они больше фокусируются на таких аспектах, как производительность [33], где проектируется граф зависимостей для выявления узких мест, или сосредоточены на конкретной области, например, производстве [34], или симуляции для сред Edge/Fog-вычислений [35, 36] с миграцией сервисов, динамическим формированием распределенных кластеров и развертыванием микросервисов, или фокусируются на производительности нативных облачных цепочек микросервисов [37], или устойчивости микросервисной системы при возникновении сбоев [38], или на проблеме интеграции нескольких симуляторов для встраиваемых систем [39]. В целом, эти симуляторы игнорируют сложность бизнес-логики некоторых микросервисных систем.

Проводятся исследования по расширению агрегатов для обеспечения согласованности между репликами сущностей в распределенных системах, интенсивно использующих данные, таких как микросервисы [40]. Они решают тот же тип проблем, общих для микросервисных систем, которые наш симулятор намерен выявлять посредством симуляции.

# Шаблоны транзакционной саги
Как упоминалось ранее, множественные комбинации ключевых измерений могут генерировать ряд различных шаблонов транзакционной саги (Transactional Saga patterns). Эта идея хорошо представлена в книге Форда и соавт. [18], откуда мы можем взять шаблоны в Таблице 3.1 ниже.

## Существующие инструменты и фреймворки
Уже существуют некоторые инструменты и фреймворки, которые помогают разработчикам в процессе создания микросервисных систем, использующих транзакционный шаблон Saga. Есть исследования, сравнивающие некоторые из этих инструментов [12, 13]. На их основе мы черпали вдохновение для поиска и предложения значимых альтернатив для исследования в симуляторе.

### Eventuate Tram Sagas

Eventuate Tram [23] — это фреймворк с открытым исходным кодом, который облегчает разработку приложений, когда речь идет о транзакционном обмене сообщениями и Сагах (Sagas). Основное внимание в этом фреймворке уделяется Сагам с асинхронным стилем связи, таким как Fantasy Fiction Saga (aao), Horror Story Saga (aac), Parallel Saga и Anthology Saga (aec) из Таблицы 3.1. Этот фреймворк предоставляет абстрактные классы, интерфейсы и DSL, на основе которых разработчики могут создавать и использовать конечный автомат Саги. Эти интерфейсы и переопределение методов способствуют полиморфизму, который поддерживает повторное использование компонентов фреймворка.

Агрегаты не только представляют элементы предметной области, но и реализуют бизнес-логику, которую можно описать с помощью конечного автомата. Это состоит из определения нескольких групп методов, каждая группа соответствует Саге. Создание Саги — это простой процесс расширения класса Saga, как показано на Рисунке 3.1:

Определить оркестратор (a) Определить последовательность шагов, которые Сага должна выполнить в рамках функциональности; (b) Указать обработчики для каждого шага с логикой того, что должно произойти при выполнении шага; (c) Определить компенсирующие действия для каждого шага на случай сбоя; (d) Установить условия, определяющие, когда Сага должна перейти к следующему шагу или завершиться.

Определить участников (a) Определить методы, которые вызываются с помощью команд оркестратором.

Для оркестратора и участников должны быть реализованы обработчики команд сервисов.

Хотя фреймворк предназначен для распределенных систем, он также может быть развернут централизованно. Он предоставляет необходимые средства для локального тестирования и, таким образом, симулирует распределенную среду и некоторые из ее характеристик, такие как асинхронная связь, последовательности выполнения и координации Саги, транзакционный обмен сообщениями, сценарии сбоев и логика компенсации, а также концепция конечной согласованности.

Этот фреймворк позволяет легко специфицировать и реализовывать микросервисы, сохраняя при этом высокую степень выразительности. Фреймворк предоставляет структурированный способ определения Саг посредством оркестровки нескольких микросервисов (участников). Эта оркестровка включает определение последовательности шагов, обработку каждого шага и определение компенсирующих действий для сбоев. Это делает сложные взаимодействия в распределенной системе более ясными и управляемыми. Общение обычно происходит через команды и события. Команды — это директивы для выполнения действия, а события сигнализируют о том, что что-то произошло. Этот метод связи выразителен, поскольку четко разграничивает действия (команды) и реакции (события) внутри системы. Он хорошо задокументирован и умеренно прост в использовании и настройке. Однако он немного ограничен в отношении различных типов Саг, которые можно реализовать, особенно с учетом высокой степени сложности спецификации, предложенной Фордом и соавт. [18].

Листинг 3.1 показывает простой вариант того, как ранее обсуждавшаяся функциональность AddParticipant может быть реализована с помощью Eventuate в качестве Саги. Сначала определяется компенсирующее действие (строки 5-6) на случай сбоя последующих шагов. Затем следующий шаг (строки 8-9) создает командное сообщение getParticipant, вызывая AddParticipantSagaData.getParticipant(), и отправляет его в канал, указанный courseExecutionService.getParticipant. Наконец, если от courseExecutionService получен успешный ответ, выполняется saveTournamentCourseExecution() (строки 10-11).

### Temporal

Temporal [24] также является фреймворком с открытым исходным кодом для создания отказоустойчивых, распределенных и масштабируемых приложений. Он имеет несколько функций, таких как оркестровка рабочих процессов (workflow orchestration), управление состоянием или логика повторных попыток и компенсации, которые могут быть полезны при разработке шаблонов на основе Саги. Абстракция, модульность, инкапсуляция и наследование — вот некоторые из принципов проектирования, на которых основан Temporal и которые укрепляют его как жизнеспособный объектно-ориентированный фреймворк, который может быть легко повторно использован в различных приложениях и контекстах.

Хотя в Temporal нет прямого эквивалента агрегатов и Саг, концепция Рабочего процесса (Workflow) имеет некоторое сходство, в частности, в управлении бизнес-логикой, поддержании состояния, а также обеспечении согласованности и отказоустойчивости. У каждого Рабочего процесса есть действия (activities), которые соответствуют шагам в Саге.

Для воспроизведения реализации Саги можно использовать следующие шаги:

Определить Действия (Activities): Это шаги транзакции и соответствующие им компенсации.

Определить Интерфейс Рабочего процесса (Workflow Interface): Он будет оркестровать действия.

Реализовать Рабочий процесс (Workflow): Определить логику для выполнения действий и обработки сбоев.

На Рисунке 3.2 представлены классы, необходимые для реализации эквивалентного поведения Саги в Temporal.

Temporal также может быть запущен в локальной среде с помощью таких технологий, как Docker, для целей симуляции, но не в одном процессе, как симулятор транзакционных причинно-согласованных микросервисов (Transactional Causal Consistent Microservices Simulator).

Этот фреймворк также хорошо задокументирован, но номенклатура концепций требует некоторой адаптации, что может потребовать дополнительных усилий от пользователя. Хотя он позволяет разрабатывать сложные системы и приложения, ему также недостает универсальности в отношении различных типов Саг, предложенных Фордом и соавт. [18].

Основное различие между Temporal и Eventuate Tram Sagas заключается в том, что Temporal фокусируется на оркестровке сложных рабочих процессов и действий, предоставляя надежный фреймворк для управления состоянием и отказоустойчивости, тогда как Eventuate фокусируется на управлении распределенными транзакциями с использованием шаблона Саги. Temporal более ориентирован на процессы, сосредоточен на оркестровке рабочих процессов и длительных процессах с сохранением состояния, в отличие от Eventuate, который более ориентирован на транзакции.

Листинг 3.2 показывает простой вариант того, как ранее обсуждавшаяся функциональность AddParticipant может быть реализована с помощью Temporal. Во-первых, определяется интерфейс для действий (строки 2-9). Затем эти методы должны быть реализованы в соответствии с бизнес-логикой. После этого определяется интерфейс для рабочего процесса (строки 12-16). Наконец, реализуется рабочий процесс (строки 28-40). Можно настроить несколько параметров выполнения действий, например, таймеры повторных попыток. Затем выполняются указанные действия и соответствующие компенсирующие действия.

### SagaMAS

SagaMAS [25] — это, по сути, разрабатываемый фреймворк на основе мультиагентной системы, где аспекты связи и координации Саг обрабатываются принципами мультиагентных систем. Хотя конкретной реализации пока нет, идея состоит в том, что каждый микросервис связан с определенным агентом. Этот агент может располагаться на том же сервере, что и микросервис, или в другом месте. Когда в микросервисе инициируется транзакция, он сообщает о начале этой транзакции связанному с ним агенту. После того как агент проинформирован о начале транзакции, независимый мультиагентный уровень берет на себя обработку транзакции. Этот уровень также отвечает за управление любыми ошибками, связанными с транзакциями и самим агентским уровнем. При этом новизна заключается в том, что происходит разделение аспекта координации транзакций, который становится обязанностью агентского уровня, открывая дверь для будущих решений и открытий в области ИИ. Поскольку его реализация еще не общедоступна, трудно предсказать, как следует использовать этот фреймворк. Однако авторы указывают, что разработчики должны определить следующие предикаты:

incoming action(st name, action): для определения действия, которое должно быть выполнено в микросервисе для данной субтранзакции.

compensation action(st name, action): для определения действия, которое должно быть выполнено в случае возникновения проблемы в транзакции в качестве компенсирующего механизма.

next(st name, agent): для определения агента, который должен выполнить данную субтранзакцию.

next(st name, new st name, agent): для связывания существующей субтранзакции с новой субтранзакцией и установки агента, который ее запустит. Это может быть использовано для определения непростых путей в транзакции без двусмысленности.

Листинг 3.3 показывает, как это транслируется в функциональность AddParticipant.

Хотя в статье не упоминаются другие транзакционные модели, кроме Саг, идея использования архитектуры мультиагентной системы, которая отвечает за аспекты координации микросервисов, может быть исследована для других моделей, таких как TCC, например, или даже комбинации, где разные сервисы не следуют одной и той же модели. Это становится возможным благодаря уровню абстракции, предоставляемому использованием агентов.

### Обзор сравнения

Таблицы 3.2 и 3.3 показывают сравнения между упомянутыми фреймворками.

Следует принять во внимание, что в Eventuate Tram Sagas элементы функциональности и координации отделены от фактического сервиса. Попытка реализовать эту структуру может быть предпринята в TCC Microservices Simulator, который использует концепции агрегатов для инкапсуляции бизнес-логики и данных, и сервисов для обработки бизнес-операций, связанных с этими агрегатами. Это потребовало бы переписать функциональности и сервисы так, чтобы они были отделены от транзакционной модели.

Расширение симулятора для поддержки Саг представляло собой значительную проблему; были приняты во внимание некоторые соображения, касающиеся его архитектуры и механизмов:

Функциональности были определены как механизм координации, привязанный к операциям сервиса агрегата. Чтобы учесть Саги, важно концептуализировать эти функциональности как шаги Саги, которые по сути являются вызовами сервисов. Этот сдвиг потребует переосмысления того, как симулятор обрабатывает операции, делая их серией взаимосвязанных действий в нескольких сервисах.

Единица работы (Unit of Work) симулятора поддерживала транзакционную модель, а не прямую координацию. Расширение симулятора для Саг включало интеграцию механизма оркестровки или хореографии для координации этих шагов Саги. Для достижения этого была реализована другая версия единицы работы, поскольку ее основная цель заключалась в поддержке транзакционной модели, а не координации.

Связь в симуляторе TCC была в основном прямыми вызовами и публикацией и подпиской на события. Для Саг стратегия связи была расширена, чтобы включать как прямые вызовы сервисов, так и асинхронный обмен сообщениями (команды и события), которые типичны для реализаций Саги. Это обеспечивает большую развязку между сервисами и большую гибкость, поскольку поведение сервисов ранее было жестко закодировано.

Одним из наиболее значимых аспектов шаблона Саги является его подход к обработке сбоев через компенсирующие транзакции. Поскольку симулятор TCC в его предыдущей форме не учитывал логику компенсации из-за атомарной природы TCC, ключевой частью расширения было введение и интеграция этого механизма. Это включало разработку способов отмены эффектов предыдущих операций в Саге, когда последующая операция завершается неудачей.

В заключение, обеспечение совместимости TCC Microservices Simulator с Сагами потребовало значительных изменений в его основной структуре, особенно если принять во внимание различные шаблоны Саги, изложенные Нилом Фордом и соавт. [18].

## Сравнение с разработанным фреймворком
В этом разделе мы сравниваем предложенный фреймворк микросервисов с другими существующими решениями, чтобы выделить его сильные стороны и области для улучшения. В то время как многие фреймворки предоставляют инструменты для микросервисной архитектуры, такие как обработка распределенных транзакций и связи, фреймворк, разработанный в этой диссертации, имеет уникальные преимущества с точки зрения гибкости, предметно-ориентированного проектирования и простоты тестирования.

### Eventuate Tram Sagas

Eventuate Tram Sagas — это известный фреймворк для реализации распределенных транзакций с использованием шаблона Саги. Как и наш фреймворк, он поддерживает компенсирующие транзакции и связь на основе событий, что помогает обеспечить конечную согласованность между сервисами. Однако Eventuate Tram Sagas ориентирован в первую очередь на асинхронную связь и не имеет прямой поддержки принципов предметно-ориентированного проектирования.

Наш фреймворк, с другой стороны, глубоко интегрирует предметно-ориентированное проектирование в архитектуру, облегчая разработчикам прямое отображение их бизнес-логики в микросервисы без дополнительной сложности. Кроме того, поддержка отношений агрегатов "вверх по течению — вниз по течению" (upstream-downstream) в нашем фреймворке способствует более четкому разделению обязанностей между командами, снижая зависимости и повышая производительность.

### Temporal

Temporal — это еще один фреймворк, который позволяет разработчикам создавать отказоустойчивые, распределенные системы. Он фокусируется на оркестровке рабочих процессов и предлагает сильные механизмы управления состоянием и повторных попыток для длительных процессов. Основная сила Temporal заключается в его способности обрабатывать сложные рабочие процессы с отказоустойчивостью, что полезно для определенных вариантов использования, но это также может привести к сложности в плане настройки и установки.

По сравнению с Temporal, наш фреймворк предлагает более легкий подход, с более простым процессом настройки, что облегчает начало работы небольшим командам или проектам, которые не требуют сложного управления состоянием. В то время как Temporal превосходит в обработке очень сложных рабочих процессов, наш фреймворк находит баланс между гибкостью и простотой использования, обеспечивая достаточную надежность для большинства бизнес-приложений без ненужных накладных расходов.

### SagaMAS

SagaMAS — это система на основе мультиагентов, которая управляет распределенными транзакциями через агентов. Она представляет инновационный подход, разделяя координацию транзакций с самими сервисами, позволяя координации обрабатываться независимо. Однако SagaMAS все еще находится на ранней стадии, и его практическое применение еще предстоит полностью изучить.

Наш фреймворк, напротив, уже полностью реализован и протестирован, предоставляя конкретные инструменты для обработки распределенных транзакций с четко определенными шаблонами. Включив как семантические блокировки, так и компенсирующие транзакции, наш фреймворк предоставляет надежное решение для обеспечения согласованности, позволяя командам работать независимо над своими сервисами.

### Общее сравнение

Каждый из сравниваемых фреймворков имеет свои сильные стороны, но наш фреймворк предлагает уникальную комбинацию функций, которые делают его особенно подходящим для команд разработчиков, следующих предметно-ориентированному проектированию и стремящихся симулировать сложные взаимодействия микросервисов на ранней стадии процесса разработки.

## Симуляция в микросервисах
С ростом популярности микросервисных архитектур также возникает потребность в хороших и надежных средах и инструментах симуляции для этих систем [41, 42]. В этом разделе мы рассмотрим некоторые работы, которые уже были разработаны в этой области.

### FERAL

FERAL [39], как следует из названия, — это Фреймворк для Эффективного Сопряжения симуляторов на уровне Требований и Архитектуры (Framework for Efficient simulator coupling on Requirements and Architecture level). Feral пытается решить несколько проблем, когда речь идет о точном прогнозировании поведения встраиваемых систем в сложных средах. Поведение связи, системные среды и функциональное поведение системных компонентов — вот некоторые характеристики, которые обычно включают сопряжение специализированных симуляторов. Это приводит к ограниченной гибкости в выборе симуляторов и неспособности эффективно создавать интегрированные сценарии. Чтобы решить эту проблему, FERAL обеспечивает интеграцию гетерогенных симуляторов и моделей симуляции, предлагая высокий потенциал повторного использования, упрощая интеграцию симуляторов и обеспечивая быстрое развитие сценариев сопряжения симуляторов. Фреймворк нацелен на решение проблем семантической интеграции между симуляторами, корректной синхронизации и необходимости расширяемости для размещения дополнительных симуляторов и моделей. Хотя FERAL сосредоточен на встраиваемых системах, работая с взаимодействием аппаратного и программного обеспечения, есть некоторые ключевые идеи, которые могут быть приняты во внимание при разработке симулятора микросервисов. Оба включают множество компонентов. Feral интегрирует несколько симуляторов в один фреймворк; аналогично, симулятор микросервисов намерен интегрировать различные транзакционные модели, архитектурные стили и шаблоны в рамках микросервисных систем. Симулятор позволит симулировать различные комбинации аспектов, таких как Саги или TCC и синхронная или асинхронная связь. Оба стремятся быть модульными и гибкими, позволяя повторно использовать компоненты и адаптироваться к различным потребностям симуляции. Для достижения высокого уровня модульности, как в FERAL, симулятор мог бы попытаться максимизировать количество независимых компонентов/модулей, чтобы их можно было легко заменять и они работали независимо, не влияя друг на друга. Это также облегчило бы добавление новых функций, моделей и симулирующих компонентов, способствуя лучшей расширяемости. Поскольку FERAL позволяет использовать различные модели выполнения, которые интегрированы как директоры, симулятор мог бы попробовать аналогичный подход, где выполнение и связь также управляются в независимых уровнях. Корректная синхронизация FERAL, которая относится к точному координированию нескольких компонентов симуляции, — это концепция, которая также может быть применена к симулятору. Это обеспечило бы когезивное взаимодействие нескольких микросервисов, даже если они следуют различным транзакционным шаблонам. Это также важно в контексте распределенных систем, где сервисы могут работать асинхронно или зависеть от выходных данных друг друга.

### µqSim

µqSim [43] — это масштабируемый и валидированный симулятор сети очередей для интерактивных микросервисов. Основные проблемы, решаемые µqSim, — это сложность, вызванная переходом от монолитных конструкций к микросервисам, и трудность в изучении микросервисов в масштабе. µqSim предоставляет подробные внутри- и межмикросервисные модели, позволяя точно воспроизводить сложные приложения. µqSim модульный, поддерживая повторное использование отдельных моделей в разных микросервисах и приложениях. Аналогично тому, что обсуждалось в 3.4, хотя основным фокусом µqSim являются микросервисы, и его предметная область немного отличается от симулятора микросервисов, есть некоторые моменты, которые можно рассмотреть. µqSim фокусируется на микросервисах, подчеркивая масштабируемость и производительность в интерактивных системах, в то время как симулятор фокусируется на исследовании транзакционных моделей в микросервисах. Несмотря на то, что µqSim специально нацелен на метрики производительности, такие как пропускная способность и задержка в хвосте, он также был разработан с учетом адаптивности и модульности, что позволяет повторно использовать компоненты, как и симулятор микросервисов. µqSim также предоставляет пользователям возможность использовать высокоуровневые, декларативные спецификации графа зависимостей микросервисов и серверных платформ. Что-то подобное может быть реализовано в симуляторе, чтобы позволить спецификацию конфигурации или более легкую разработку тестирования.

Эти работы укрепляют растущее внедрение микросервисов и подтверждают потребность в симуляторах и инструментах, которые помогают в их понимании и разработке. Обе работы предоставляют ценные сведения о том, как подходить и моделировать среду симуляции и как обрабатывать сложность в микросервисных архитектурах.

# Симулятор микросервисов Sagas
Симулятор микросервисов поддерживает концепции предметно-ориентированного проектирования (domain-driven design) и их интеграцию в микросервисной архитектуре. Кроме того, он предоставляет централизованный механизм выполнения, который симулирует выполнение Саг в распределенной среде.

В этом разделе представлена реализация и адаптация ключевых концепций в архитектуре микросервисов, сфокусированная на интеграции паттерна Saga во фреймворк симулятора. Для достижения этой цели предыдущий TCC-симулятор был расширен и адаптирован, чтобы обеспечить поддержку обеих транзакционных моделей.

Следующие разделы объясняют, как были адаптированы агрегаты (aggregates) для поддержки архитектуры Saga, как рабочие процессы (workflows) и паттерн единица работы (unit of work) были использованы для управления функциональностью, а также описывают остальные структурные изменения, внесенные в симулятор.

## Обзор

Для поддержки архитектуры и симуляции Саг были внесены некоторые изменения и рефакторинг в структуру симулятора. Их можно увидеть на Рисунке 4.1. В этом обновленном представлении реализован новый модуль для координации (coordination). Он содержит абстракции для unitOfWork и workflow, которые будут использоваться для определения транзакционной логики. unitOfWork отвечает за управление транзакционным аспектом операций. workflow отвечает за определение и управление последовательностью, в которой выполняются бизнес-операции. Каждый из них также расширяется в соответствии с конкретной транзакционной моделью. Эти абстрактные модули отделяют транзакционное поведение от логики выполнения функциональности. Что касается реализации викторин (quizzes), появляется новый модуль, эквивалентный quizzes causal, но для модели Saga. Эти модули содержат расширение агрегатов и определения рабочих процессов для поведения каждой функциональности, специфичных для каждой модели. Наконец, quizzes microservices содержит все компоненты, общие для обеих транзакционных моделей.

Симулятор поддерживает спецификацию агрегатов, которые готовы к выполнению в соответствии с транзакционной моделью Sagas. На Рисунке 4.2 представлены основные сущности доменной модели симулятора для представления Саг. Для обеспечения модульности и расширяемости модель имеет разные уровни связности. Классы красного и зеленого цвета не зависят от прикладного домена; они принадлежат к ядру симулятора и повторно используются для всех симуляций. Красные классы связаны с определением агрегатов, а зеленые классы – с определением транзакционной модели Sagas; следовательно, возможно расширить симулятор для поддержки других транзакционных моделей. Синие и оранжевые классы зависят от приложения, при этом синие не зависят от транзакционной модели, а оранжевые специфичны для транзакционной модели Sagas. Центральным понятием является агрегат, который включает набор сущностей и имеет уникальный идентификатор, чтобы другие микросервисы могли на него ссылаться. Абстрактный класс Aggregate имеет уникальный aggregateId и определяет два абстрактных метода: verifyInvariants, который определяет инварианты агрегатов; и getEventSubscriptions, который определяет события, на которые он подписывается от вышестоящих микросервисов. На рисунке эти методы переопределены в Tournament. Кроме того, Tournament ссылается на другие сущности, входящие в агрегат: Participant и TournamentQuiz. Обратите внимание, что эти сущности не являются агрегатами.

Интерфейс SagaAggregate предоставляет методы для поддержки семантических блокировок (getSagaState и setSagaState). Эти методы реализованы в SagaTournament для обогащения Tournament управлением транзакциями Sagas. Кроме того, реализации интерфейса SagaState определяют семантические блокировки для каждого типа агрегата.

Абстрактные классы Event, EventSubscription и EventHandler определяют ядро симулятора для асинхронной обработки событий по схеме "upstream-downstream" (отправитель-получатель). Вышестоящие микросервисы генерируют свои события во время выполнения сервисов, а нижестоящие реализуют EventSubscription и EventHandler, чтобы, соответственно, подписаться и обработать интересующие их события. Экземпляры EventSubscription возвращаются методом getEventSubscriptions агрегата.

Ниже мы представляем код для некоторых расширений симулятора для системы Quizzes Tutor.

Код в Листинге 4.1 демонстрирует определение двух методов в агрегате Tournament: для проверки инвариантов, строки 1-6, и подписки на события, строки 8-14. Для подписки на события регистрируется экземпляр TournamentSubscribesUpdateStudentName, метод subscribesEvent которого определен для проверки наличия события UpdateStudentNameEvent для одного из участников турнира, как показано в следующем коде в Листинге 4.2.

Обработка событий запускает выполнение функциональности. Симулятор периодически обрабатывает события, вызывая метод handleEvent в TournamentUpdateStudentNameEventHandler.

Наконец, класс TournamentService определяет методы API микросервиса, в данном случае для микросервиса Tournament. Симулятор ожидает, что для каждого микросервиса будет определен класс, и хотя он не наследуется от абстрактного класса, общего для всех API микросервисов, он повторно использует некоторые общие методы, предоставляемые координационной частью симулятора, такие как, например, метод для генерации событий (registerEvent) или обновления измененных агрегатов (registerChanged) в классе UnitOfWorkService на Рисунке 4.3.

В методе addParticipant API микросервиса Tournament, показанном в Листинге 4.3, агрегат турнира считывается с использованием сервиса единицы работы, строки 3-4, затем дублируется, строка 5, и добавляется участник, строка 6. Наконец, новый агрегат регистрируется в сервисе единицы работы Saga для фиксации (commit), строка 7.

## Проектирование Координации

Проектирование координации описывает, как функциональность системы достигается за счет взаимодействия нескольких микросервисов. Выполнение функциональности системы запускается внешним взаимодействием с системой, например, обновлением имени студента.

Дизайн применяет паттерн Единица Работы (Unit of Work) для определения транзакционного контекста, связанного с выполнением функциональности [44], и паттерны Рабочего Процесса (Workflow) для определения координации нескольких сервисов [45].

Чтобы определить функциональность, необходимо реализовать один класс, такой как AddParticipantFunctionalitySagas на Рисунке 4.3, для добавления студента в качестве участника турнира. Этот класс использует основные классы координации симулятора, которые будут управлять выполнением функциональности. Архитектору нужно только определить метод реализации координации buildWorkflow и указать события, которые, возможно, потребуется обработать во время выполнения функциональности, метод handleEvents. Последнее связано с тем, что во время выполнения Саги функциональность может быть заинтересована в каком-либо событии, произошедшем в агрегате, с которым она взаимодействовала.

Вызов метода executeWorkflow в WorklowFunctionlity запускает выполнение конкретной функциональности в соответствии с координацией, определенной в Workflow. Выполнение начинается с создания SagaUnitOfWork, который регистрирует измененные агрегаты и события, которые необходимо сгенерировать в результате выполнения функциональности. Он также сохраняет компенсационные операции (compensation operations) на случай, если выполнение функциональности должно быть прервано (abort). SagaUnitOfWorkService — это транзакционный менеджер, ответственный за инициализацию единицы работы и принятие решения о ее фиксации или прерывании.

Симулятор реализует простой рабочий процесс, который состоит из набора FlowStep, имеющих зависимость выполнения между собой. Зависимости используются для генерации плана выполнения. Каждый шаг (flow step) выполняется в своем собственном потоке. Существует два типа FlowStep: SyncStep, где рабочий процесс ожидает завершения вызываемого объекта перед выполнением следующего шага; и AsyncStep, где рабочий процесс выполняет шаги асинхронно и использует фьючерсы (futures) для синхронизации доступности результатов [46]. Две используемые в Java конструкции, Runnable и Supplier, в своих атрибутах операции инкапсулируют вызов API микросервиса, такой как метод addParticipant класса TournamentService на Рисунке 4.2. Наконец, подклассы SagaSyncStep и SagaAsyncStep определяют компенсирующие операции, связанные с каждым шагом, которые добавляются в UnitOfWork при выполнении шага с помощью метода registerCompensation.

Листинг 4.4 представляет метод buildWorkflow класса addParticipantFunctionalitySagas. Он начинается с создания рабочего процесса Saga, состоящего из 2 шагов. Первый шаг, строки 4-10, получает информацию о студенте из API микросервиса Course, вызывая getStudentById. Второй шаг создает сущность Participant, используя информацию, полученную с предыдущего шага через getStudentDto; затем вызывает метод addParticipant API микросервиса Tournament. Создание шага также указывает, что getStudentStep должен предшествовать ему (добавляется к шагу с использованием массива), строка 18. Наконец, шаги добавляются в рабочий процесс в последних трех инструкциях, строки 20-21.

Другим примером, в котором используются семантические блокировки и компенсационные операции, является функциональность UpdateTournamentFunctionalitySagas, которая обновляет два агрегата: Tournament и Quiz. Это показано в Листинге 4.5.

В этой функциональности видно, что исходный турнир сохраняется в Саге, полученный на первом шаге (getOriginalTournamentStep), так что в случае прерывания он используется в компенсационной операции (registerCompensation) второго шага (updateTournamentStep). Это может произойти, если третий шаг updateQuizStep завершится неудачей. На втором шаге в турнир записывается семантическая блокировка (IN UPDATE TOURNAMENT), строки 21-22. Блокировка снимается (NOT IN SAGA) в компенсационной операции, строка 30. В соответствии с бизнес-логикой этой функциональности, невозможно иметь два одновременных обновления одного и того же турнира, что проверяется в getOriginalTournamentStep, и если это так, генерируется исключение, строки 8-11.

После того как рабочий процесс, связанный с функциональностью, построен, он выполняется в соответствии с транзакционным поведением Sagas, которое реализовано с применением паттерна Единица Работы. Для применения паттерна определены два класса: SagaUnitOfWorkService и SagaUnitOfWork, где первый соответствует API, предоставляемому функциональности, а второй содержит состояние выполнения Саги.

Новый экземпляр SagaUnitOfWork передается в метод buildWorkflow и передается каждому из сервисов, выполняемых функциональностью. Сервисы регистрируют обновленные агрегаты и события, которые должны быть сгенерированы в результате выполнения их бизнес-логики (методы registerChanged и registerEvent в SagaUnitOfWorkService, см. код сервиса addParticipant для случая registerChanged). Для registerChanged SagaUnitOfWorkService проверяет инварианты агрегата, и если они проходят, он записывает обновленный агрегат, в противном случае он прерывает выполнение функциональности. Обратите внимание, что таким образом промежуточное состояние агрегата становится видимым до фиксации функциональности, что является ожидаемым отсутствием изоляции в поведении Саг. Для реализации registerEvent событие записывается и может быть подписано. Поскольку метод registerChanged может привести к прерыванию, в сервисе он всегда должен вызываться перед registerEvent, чтобы гарантировать, что событие публикуется только в том случае, если сервис не прерывается. С другой стороны, когда семантическая блокировка записывается в контексте выполнения рабочего процесса, метод registerSagaState в SagaUnitOfWorkService записывает агрегат, чтобы другие функциональности могли прочитать семантическую блокировку, и он также добавляется к набору aggregatesInSaga в SagaUnitOfWork.

В конце выполнения функциональности рабочий процесс вызывает метод commit в SagaUnitOfWorkService. Он снимает все семантические блокировки для набора aggregatesInSaga. Если во время выполнения функциональности происходит прерывание, компенсационные операции вызываются в обратном порядке их регистрации. Обратите внимание, что при выполнении SagaStep он регистрирует свою компенсирующую операцию в SagaUnitOfWork.

Симулятор реализован как приложение Spring Boot\footnote{https://spring.io/projects/spring-boot} и находится в открытом доступе.

## Проектирование Рабочего Процесса

Проектирование рабочего процесса в симуляторе реализует координацию множества микросервисов, обеспечивая надлежащую обработку распределенных транзакций, особенно в контексте Саг. Рабочие процессы реализуются с помощью плана выполнения (ExecutionPlan), который организует шаги, необходимые для завершения функциональности, в зависимости от зависимостей, указанных разработчиком при построении рабочего процесса. Основные компоненты рабочего процесса включают методы ExecutionPlan, planOrder и execute, которые управляют упорядочиванием и выполнением шагов в рабочем процессе.

Класс ExecutionPlan отвечает за управление шагами рабочего процесса и их зависимостями. Он поддерживает список шагов и их статусы выполнения, что позволяет симулятору контролировать, когда каждый шаг может быть выполнен на основе его зависимостей. Шаги без зависимостей выполняются немедленно, в то время как шаги с зависимостями ожидают завершения всех предварительных шагов.

Метод planOrder, показанный в Листинге 4.6, определяет порядок шагов в рабочем процессе, анализируя их зависимости. Он вычисляет входящую степень (количество зависимостей) для каждого шага, строки 3-5, и использует очередь для управления шагами, готовыми к выполнению. Этот метод гарантирует, что шаги выполняются в правильном порядке, избегая при этом циклических зависимостей, которые могут привести к взаимоблокировкам или несогласованным состояниям.

После того как шаги упорядочены с помощью метода planOrder, метод execute, показанный в Листинге 4.7, отвечает за запуск рабочего процесса. Он выполняет каждый шаг последовательно или параллельно, в зависимости от того, являются ли шаги синхронными или асинхронными. Этот метод также обрабатывает компенсации в случае сбоя шага, обеспечивая согласованность системы путем вызова зарегистрированных компенсационных действий в обратном порядке.

Метод execute инициирует выполнение рабочего процесса, фиксирует транзакцию, если она успешна, или прерывает и компенсирует, если возникает исключение.

Для симуляции параллелизма в системе микросервисов симулятор позволяет разработчикам использовать методы executeUntilStep и resume. Эти методы позволяют приостанавливать и возобновлять рабочий процесс на определенных шагах, симулируя сценарии, когда несколько рабочих процессов выполняются параллельно.

Метод executeUntilStep позволяет выполнять рабочий процесс до определенного шага. Это полезно для симуляции частичных выполнений, когда процесс прерывается, и система должна обрабатывать параллельные модификации или другие рабочие процессы, работающие параллельно. После того как рабочий процесс был приостановлен на определенном шаге, метод resume может использоваться для продолжения выполнения с этой точки. Это симулирует реальные сценарии, когда процесс возобновляется после ожидания внешних условий или завершения параллельных транзакций. Оба эти метода показаны в Листинге 4.8.

Комбинируя использование executeUntilStep и resume, симулятор может моделировать сложное чередование между рабочими процессами, позволяя разработчикам тестировать параллельные сценарии, в которых несколько рабочих процессов затрагивают один и тот же набор микросервисов. Это особенно полезно в распределенных системах, где параллелизм может создавать проблемы, такие как состояния гонки (race conditions), несогласованные состояния (inconsistent states) и необходимость в компенсирующих транзакциях (compensating transactions).

Параллелизм в микросервисных системах может привести к несогласованным состояниям, если его не обрабатывать правильно. Используя способность симулятора приостанавливать и возобновлять рабочие процессы, а также компенсационные механизмы Саг, можно разрешить эти несогласованности. Например, если два рабочих процесса пытаются изменить один и тот же агрегат, симулятор может симулировать завершение одного рабочего процесса, в то время как другой компенсирует любые конфликты.

Симулятор гарантирует, что шаги рабочего процесса выполняются в правильном порядке и что компенсации применяются, когда это необходимо, предоставляя надежный фреймворк для тестирования параллельных взаимодействий микросервисов.

# Фреймворк Симулятора Микросервисов
Благодаря этим адаптациям, внесенным в симулятор, предыдущий TCC-симулятор был обогащен и теперь также позволяет симулировать Саги. Внесенные структурные изменения позволяют разработчикам повторно использовать большую часть кода, имея в качестве задачи только переписывание спецификаций агрегатов и функциональностей в соответствии с желаемой транзакционной моделью. Используя рабочие процессы, симулятор теперь предоставляет унифицированный фреймворк, где могут симулироваться различные транзакционные поведения, обеспечивая сосуществование обеих моделей и гибкую обработку сложных транзакций.

# Оценка
Для оценки симулятора мы показываем, что он поддерживает аспекты, выявленные в постановке задачи, требует минимальных усилий для расширения и позволяет тестировать сложные взаимодействия. Наконец, была реализована большая микросервисная система с использованием симулятора, и представлены извлеченные уроки.

## Полнота

Решение охватывает все выявленные аспекты микросервисных систем, используя подход предметно-ориентированного проектирования (domain-driven design), описанный в Разделе 2.1.

Атомарные Агрегаты: Атомарные агрегаты поддерживаются, поскольку каждый сервис выполняется в контексте транзакции ACID (@Transactional в реализации сервиса). Более того, когда сервис считывает агрегат, он считывает полный агрегат, клонирует его, вносит изменения в клон, а затем записывает его (внутри registerChanged);

Инварианты Агрегата: Инварианты агрегата сохраняются, поскольку при каждом атомарном изменении агрегата проверяются все инварианты. Метод verifyInvariants агрегата вызывается registerChanged, и если проверка завершается неудачно, функциональность прерывается;

Отношения "Вышестоящий-Нижестоящий" Между Агрегатами: Отношения "нижестоящий-вышестоящий" между агрегатами поддерживаются через API сервисов и коммуникацию событий. Сервис генерирует события, вызывая registerEvent в конце своего выполнения, и каждый агрегат определяет свои подписки на события и их обработку;

Промежуточные Состояния Агрегата: Состояние добавляется ко всем агрегатам Саги через реализацию интерфейсов SagaAggregate и SagaState, где последний позволяет определять промежуточные состояния, специфичные для агрегата. Промежуточные состояния управляются функциональностями и отделены от бизнес-логики сервиса, поскольку управление Сагой осуществляется на уровне выполнения функциональности. Следовательно, функциональность отвечает за считывание и запись семантических блокировок.

## Простота Расширения

На Рисунке 5.1 показаны шаги по реализации агрегата путем расширения симулятора. Это итеративный процесс, который начинается с определения структуры и инвариантов для каждого агрегата. Первое требует наследования от класса Aggregate и реализации классов для каждой из сущностей агрегата. Дополнительно может потребоваться реализация некоторых запросов для извлечения агрегата из репозитория. Сложность пропорциональна количеству сущностей, но каждое определение сущности требует только определения ее атрибутов. Что касается инвариантов агрегата, необходимо только расширить метод verifyInvariants. Сложность этой задачи равна сложности бизнес-логики, но поскольку цель симулятора состоит в том, чтобы проверить транзакционное поведение микросервисной системы, учитывая ее бизнес-логику, их реализация является обязательной.

На втором шаге основное внимание уделяется отношениям "вышестоящий-нижестоящий" агрегата. API микросервиса агрегата, предоставляемый для нижестоящих агрегатов, определяется через набор методов в классе сервиса. Эти методы должны только изменить состояние агрегата и зарегистрировать измененный агрегат в UnitOfWorkService. Кроме того, может потребоваться генерировать события, необходимые нижестоящим агрегатам, также используя UnitOfWorkService. События определяются путем расширения класса Event. Более того, необходимо подписаться на события, публикуемые вышестоящими агрегатами, путем расширения класса EventSubscription и переопределения метода агрегата getEventSubscriptions. Сложность, связанная с этим шагом, пропорциональна количеству сервисов и событий, и никакой дополнительной работы не требуется. Симулятор позволяет подписываться на события на основе состояния агрегата (см. пример выше), что требует определения некоторой логики.

Наконец, на третьем шаге функциональности агрегата реализуются с использованием транзакционной модели Саг. Для этого для каждого агрегата определяется его набор состояний Саги путем расширения SagaState. Затем, путем реализации каждой функциональности агрегата с использованием конструкций рабочего процесса симулятора, в его состояние Саги добавляются новые состояния. Также необходимо обрабатывать подписанные события путем наследования от EventHandler и реализации функциональности обработки. Это самая сложная часть с точки зрения бизнес-логики Саг, которая имеет дело с семантическими блокировками, но разработчик может сосредоточиться на основной проблеме, в то время как симулятор предоставляет механизмы для шагов функциональности и управления транзакциями.

Чтобы расширить симулятор и реализовать приложение, например, пример тьютора Quizzes, мы можем следовать структурированному подходу. Это включает определение микросервисов и установление взаимодействий между ними, используя микросервис турнира в качестве эталона.

Процесс начинается с определения основной структуры микросервиса, которая в симуляторе представлена агрегатами. Каждый агрегат инкапсулирует связанные данные и поведение, гарантируя, что изменения соответствуют бизнес-правилам и требованиям к согласованности. На Рисунке 5.2 проиллюстрирована следующая процедура, демонстрирующая, как просто реализовать микросервис в симуляторе.

Определение Агрегата Первый шаг — определить класс агрегата, такой как Tournament, который представляет центральную концепцию микросервиса. Этот класс включает основные свойства и определяет инварианты, которые должны поддерживаться (например, время начала и окончания турнира). Агрегат также должен указывать подписки на события, чтобы реагировать на соответствующие доменные события, тем самым гарантируя, что микросервис остается согласованным с изменениями, происходящими в других частях системы.

Создание Репозиториев Репозитории, такие как TournamentRepository, необходимы для сохранения агрегатов в базе данных. Они предоставляют методы для запроса и хранения агрегатов, тем самым поддерживая транзакционные операции, выполняемые во время выполнения Саги.

Определение Сервисов Сервисы агрегатов, такие как TournamentService, создаются для инкапсуляции операций бизнес-логики, связанных с агрегатом. Эти сервисы используются внутри функциональностей для манипулирования агрегатом согласованным и контролируемым образом. Например, TournamentService может предлагать методы для создания, обновления и извлечения данных о турнире.

Обработка Событий Обработка событий играет решающую роль в архитектуре симулятора. Реализации, такие как TournamentEventHandling и TournamentEventProcessing, управляют доменными событиями, которые влияют на агрегат. Эти компоненты гарантируют, что микросервис может реагировать на изменения в других частях системы, обеспечивая асинхронную обработку и в конечном счете согласованность.

Реализация Логики Саги Для поддержки распределенных транзакций используется паттерн Сага. Каждый агрегат требует соответствующей реализации Саги, такой как SagaTournament, которая управляет состоянием агрегата на протяжении всего жизненного цикла транзакции. Реализация Саги определяет возможные состояния (TournamentSagaState), которые действуют как семантические блокировки, позволяя системе обрабатывать промежуточные состояния и обеспечивать согласованность данных в нескольких сервисах.

Реализация Функциональностей Функциональности представляют собой бизнес-процессы, которые координируют выполнение рабочих процессов, используя определенные сервисы. Каждая функциональность, например CreateTournamentFunctionalitySagas, использует шаги рабочего процесса для определения последовательности операций, необходимых для бизнес-процесса, включая компенсирующие действия в случае сбоя. Это позволяет системе надежно управлять распределенными транзакциями.

Предоставление Функциональности Через Web API Чтобы сделать функциональности доступными для приложения, реализуются контроллеры Web API, такие как TournamentController. Эти контроллеры предоставляют RESTful конечные точки, которые клиенты могут вызывать для выполнения функциональностей (например, создания турнира). Контроллеры взаимодействуют с нижележащими сервисами и функциональностями, обеспечивая мост между клиентом и бизнес-логикой.

Следуя этим шагам, симулятор может быть легко расширен для реализации новых микросервисов или улучшения существующих. Как мы видели, разработчику не нужно менять какую-либо логику, связанную с основными концепциями симулятора, такими как UnitOfWork и Workflow; вместо этого он может сосредоточиться на реализации бизнес-логики. Использование агрегатов, Саг и рабочих процессов обеспечивает гибкий и модульный подход, позволяя разработчикам вводить новые функциональности, сохраняя при этом согласованность и придерживаясь бизнес-правил.

## Моделирование Перемежений

Для использования симулятора и тестирования бизнес-логики микросервисов, реализованной с использованием Саг, необходимо предоставить две возможности: (1) способность частично выполнять функциональность; (2) контроль над тем, когда обрабатывать события. Первое позволяет контролировать, когда выполняются шаги функциональности, что делает возможным перемежение их выполнения с шагами другой функциональности. Второе позволяет решить, когда происходит обработка события, потому что события обрабатываются периодически, но таким образом можно сделать их обработку детерминированной.

Листинг 5.1 показывает тест Spock (https://spockframework.org/), который иллюстрирует использование этих функций для перемежения функциональностей UpdateStudentName и AddParticipant.

В примере первый шаг функциональности добавления участника выполняется с использованием вспомогательного метода executeUntilStep (строки 8–9). Затем следует полное выполнение функциональности обновления имени студента (строка 11), а затем оставшиеся шаги функциональности добавления участника выполняются с использованием вспомогательного метода resumeWorkflow (строка 14). Первая проверка подтверждает, что студент добавлен как участник с исходным именем. Затем инициируется обработка события обновления имени с использованием метода handleUpdateStudentNameEvent (строка 21), и проверка возвращает, что у него обновленное имя (в конечном счете согласованность). Обратите внимание на использование двух разных единиц работы, uow1 и uow2, для каждой из функциональностей, addParticipantFunctionality и updateStudentNameFunctionality, соответственно.

## Сложные Перемежения

Сложные взаимодействия могут возникать в распределенных микросервисных системах, координируемых транзакционной моделью Саг. Симулятор поддерживает разработку тестовых случаев, чтобы принудительно вызвать их в детерминированном контексте и оценить их поведение. Эти тестовые случаи исследуют сценарии, в которых различные функциональности выполняются параллельно или последовательно, влияя на состояние множества агрегатов микросервисов. Тестовые сценарии могут иллюстрировать проблемы параллелизма, такие как потерянные обновления, грязные чтения и в конечном счете согласованность. Мы подчеркиваем, как модель Саг решает эти проблемы с помощью семантических блокировок, компенсаций и синхронизации на основе событий для поддержания согласованности во всей системе.

На Рисунках 5.3–5.8 описаны 6 сценариев для функциональностей обновления имени студента и добавления участника, представленных, соответственно, как Update и Add. Кроме того, рассматривается дополнительная функциональность, возникающая в результате обработки события обновления имени агрегатом Tournament, обозначенная как Event. Функциональности состоят из шагов, которые вызывают сервисы агрегатов. Например, функциональность добавления участника включает два шага, которые вызывают два сервиса: getStudent агрегата Course и addParticipant агрегата Tournament. Представлены два агрегата с их временными шкалами: Course и Tournament.

Начальное состояние сценариев, соответствующее их настройке теста, — это то, где студент, добавляемый в турнир в качестве участника, является создателем турнира, потому что мы намерены проверить инвариант, который утверждает, что участник и создатель должны иметь одинаковое имя. Кроме того, мы хотим проверить, в каких ситуациях существует в конечном счете согласованность имени между Course и Tournament.

Сценарии охватывают все перемежения, которые необходимо протестировать, и разделены на последовательные и параллельные, где в первом случае нет перемежения шагов функциональности. Задержка в конечном счете согласованности возникает между окончанием функциональности обновления имени студента и обработкой события.

В сценарии (a) имя создателя обновляется первым, а затем участник добавляется с обновленным именем.

В сценарии (b) происходит нарушение инварианта, потому что добавление считывает обновленное имя и пытается добавить участника до того, как событие будет обработано, в этой ситуации у имени создателя все еще старое имя. Нарушение обнаруживается, когда при registerChanged турнира вызывается verifyInvariants; в результате, и это также показано в сценарии, функциональность добавления участника повторяется и завершается успешно, потому что она считывает из обновленного Course.

В сценарии (c) добавление участника выполняется до обновления, и когда событие обрабатывается, обновляются и создатель, и участник.

В сценарии (d) обновление имени происходит первым, добавление считывает обновленное имя, и событие обрабатывается до того, как участник будет добавлен, что обновляет имя создателя, и инвариант сохраняется, когда участник добавляется.

В сценарии (e) обнаруживается нарушение инварианта, потому что добавление участника считывает студента до того, как он будет обновлен, а обновление имени, а также обработка события происходят до того, как участник будет добавлен; после добавления участника у создателя обновленное имя, в то время как у соответствующего участника старое имя.

В сценарии (f) обновление имени происходит между добавлением участника, но поскольку событие обрабатывается только в конце, инвариант не нарушается, потому что и у создателя, и у участника старое имя.

Рисунок 5.9 показывает сценарий, в котором происходит перемежение двух выполнений функциональности обновления турнира в одном и том же турнире. Сценарий проверяет, что семантическая блокировка предотвращает потерянные обновления. Предположим, что первое выполнение является первым, кто записывает турнир, и вторым, кто записывает викторину, что привело бы к викторине, которая не соответствует турниру. Грязное чтение также предотвращается семантической блокировкой в случаях, когда сервис updateQuiz завершается неудачей, а другие функциональности прочитали обновленный турнир (взаимодействие между функциональностями не показано на рисунке).

## Большая Монолитная Система

В этом разделе мы описываем эксперимент с участием большой микросервисной системы, сосредоточив внимание на взаимодействиях между функциональностями и агрегатами и последствиях для поддержания согласованности в распределенной микросервисной системе. Микросервисной системой, которую мы проанализировали, было приложение Quizzes Tutor, которое состояло из 8 агрегатов и соответствующих микросервисов: Course (Курс), User (Пользователь), Topic (Тема), Question (Вопрос), CourseExecution (Выполнение Курса), Quiz (Викторина), Answer (Ответ) и Tournament (Турнир).

Каждый из этих агрегатов был детально изучен для выявления количества инвариантов агрегата, зависимостей в конечном счете согласованности между агрегатами, которые соответствуют их подпискам на события, и методов API. В Таблице 5.1 показана сводка:

Например, агрегат Course управляется микросервисом Course и поддерживает два инварианта для обеспечения целостности его сущностей. Для этого агрегата нет зависимостей в конечном счете согласованности, потому что он работает независимо в пределах своего микросервиса. Напротив, агрегат Tournament значительно сложнее, содержит 13 инвариантов и 11 подписок на события, и включает множество микросервисов, таких как User, Quiz и CourseExecution.

Приведенные выше данные показывают разнообразие и распределение инвариантов и зависимостей в конечном счете согласованности в типичной микросервисной системе, давая представление о сложности обеспечения согласованности внутри и между агрегатами.

Эксперимент ясно демонстрирует, что обработка больших агрегатов с богатым набором бизнес-логики в микросервисной системе требует сложных механизмов согласованности, особенно по сравнению с монолитной архитектурой, где вся согласованность данных управляется централизованно.

Всего в эксперименте было реализовано 45 функциональностей. Функциональность связана с агрегатом, называемым основным агрегатом функциональности, и может вызывать API вышестоящих агрегатов или публиковать события для подписки нижестоящими агрегатами — вторичными агрегатами. Следующий список определяет уровни сложности, связанные с функциональностью, которые зависят от количества чтений и записей, которые она выполняет на разных агрегатах:

A: Запрос: Функциональность читает основной и/или вторичный вышестоящий агрегат.

B: Простая Функциональность: Функциональность записывает только свой основной агрегат и может читать свой основной агрегат и другие вышестоящие агрегаты.

C: Сложная Функциональность: Функциональность записывает свой основной и другие вторичные вышестоящие агрегаты, и может читать основной агрегат и другие вышестоящие агрегаты.

D: Функциональность События: Функциональность записывает вторичный нижестоящий агрегат. Это косвенная запись, потому что вышестоящий агрегат не знает нижестоящий агрегат, но нижестоящий агрегат может содержать некоторое состояние вышестоящего агрегата.

Обратите внимание, что функциональность может принадлежать более чем одному случаю, например, она может быть простой и функциональностью события, что является случаем обновления имени студента.

Чтобы лучше понять сложность и зависимости в приложении "Викторины", мы классифицировали и проанализировали 45 различных функциональностей на основе предыдущей классификации сложности (Рисунок 5.10).

Анализируя Рисунок 5.10, мы можем наблюдать разнообразный диапазон сложностей среди реализованных функциональностей Quizzes Tutor, включая случаи из всех категорий. Это доказывает, что симулятор способен поддерживать различные уровни взаимодействия и координации, от простых запросов до сложных операций, включающих несколько агрегатов и поведение, управляемое событиями. Значительное количество случаев C и D показывает, что симулятор способен тестировать сложные сценарии, где распределенные транзакции и в конечном счете согласованность играют критическую роль. Охват всех случаев также доказывает надежность симулятора при обработке различных типов взаимодействий микросервисов, гарантируя эффективное тестирование как простых операций, так и более сложных рабочих процессов, включающих распределенные транзакции и асинхронную обработку событий.

## Использование

Фреймворк предлагает мощное и гибкое решение для реализации микросервисов с использованием подхода предметно-ориентированного проектирования. Помимо этого, использование фреймворка может представлять некоторые проблемы. Одна из основных трудностей, с которыми могут столкнуться разработчики, — это определение зависимостей между шагами при написании функциональности. Этот процесс требует умеренного знания системы из-за вовлечения семантических блокировок и механизмов связи на основе событий. Эти блокировки помогают предотвратить потерянные обновления или несогласованные чтения, но добавляют сложности в реализацию, поскольку их необходимо тщательно определять на основе бизнес-логики системы.

Кроме того, разработчики должны правильно обрабатывать события для обеспечения бесперебойной межсервисной связи, что не является прямолинейным. Разные команды, работающие над различными микросервисами, могут иметь разные интерпретации событий и блокировок, что может привести к недопониманиям или конфликтующим реализациям. Следовательно, надлежащая координация между командами необходима для обеспечения эффективного использования фреймворка.

## Угрозы Достоверности

Некоторые аспекты необходимо учитывать с точки зрения угроз достоверности оценки:

Оркестровка против Хореографии — симулятор реализует функциональность с точки зрения рабочего процесса сервисов, который следует подходу оркестровки. Это ограничение симулятора, поскольку он не поддерживает набор микросервисов, где координация сервисов является хореографией. Однако, учитывая сложность бизнес-логики в среде в конечном счете согласованности, приложения, имеющие богатую бизнес-логику, должны принимать стратегию оркестровки [9].

Асинхронная Связь — связь между микросервисами обычно асинхронная, с использованием очередей сообщений, для повышения надежности системы к временным сбоям в микросервисах. Хотя мы поддерживаем как синхронные, так и асинхронные шаги, оценка была выполнена с использованием синхронной версии. Хотя это ограничение оценки, также рекомендуется, чтобы координатор ждал ответа от микросервиса, прежде чем переходить к следующему, чтобы упростить бизнес-логику, хотя связь между координатором и микросервисами осуществляется асинхронно [9]. Обратите внимание, что события в симуляторе асинхронны, но относятся к другому типу взаимодействия между микросервисами (вышестоящий-нижестоящий), и они оцениваются.

# Заключение
В заключение, предложенный в данной диссертации симулятор микросервисной системы предлагает полезный инструмент для решения задач, связанных с разработкой микросервисов, особенно при использовании транзакционной модели Sagas. Благодаря применению подхода, основанного на предметно-ориентированном проектировании (Domain-Driven Design, DDD), симулятор значительно снижает риски и затраты, связанные с проблемами, возникающими на более поздних этапах разработки. Это достигается за счет раннего выявления и устранения возможных трудностей, связанных с согласованностью данных и координацией. Оценка симулятора показывает его способность обрабатывать сложные взаимосвязи между агрегатами, обеспечивая соблюдение инвариантов и успешное разрешение конфликтов с помощью компенсирующих транзакций и семантических блокировок.

Одним из ключевых преимуществ симулятора является его гибкость в симуляции различных транзакционных моделей. Хотя он в первую очередь предназначен для симуляции шаблона Sagas с конечной согласованностью (eventual consistency), он также поддерживает Транзакционную Причинную Согласованность (Transactional Causal Consistency, TCC), более строгую модель согласованности, которая гарантирует соблюдение причинно-следственных связей между транзакциями. Эта двойная возможность позволяет симулятору моделировать как системы с конечной согласованностью, которые ставят во главу угла производительность и доступность, так и системы, требующие более строгих гарантий согласованности. Предоставляя поддержку TCC, симулятор расширяет свою применимость к более широкому кругу вариантов использования, позволяя разработчикам оценивать компромиссы между различными моделями согласованности и выбирать наиболее подходящую для их системы.

Простота расширения и поддержка симуляции сложных чередований (interleavings) операций дополнительно подчеркивают практическую полезность этого инструмента для разработчиков, стремящихся оптимизировать проектирование и функциональность своих систем на основе микросервисов. В конечном счете, прежде чем приступать к дорогостоящим реализациям в распределенных средах, разработчики могут использовать этот симулятор для исследования различных механизмов координации, оценки жизнеспособности микросервисных архитектур и принятия обоснованных проектных решений. Чтобы еще больше повысить полезность симулятора для моделирования реального поведения микросервисов, будущая разработка будет сосредоточена на его расширении для лучшего учета асинхронного выполнения шагов.

Более того, хотя текущий фокус сосредоточен на синхронных транзакциях, симулятор готов к будущему развитию, чтобы включить асинхронное выполнение шагов, что будет более точно отражать реальные микросервисные среды, где задержки сообщений и сетевые задержки являются обычным явлением. Расширение симулятора для лучшего учета асинхронных операций еще больше повысит его способность симулировать реалистичное поведение системы и оценивать ее производительность в распределенных контекстах.

В целом, предложенный симулятор не только упрощает ранние стадии проектирования микросервисных систем, но и вносит вклад в более широкие усилия по разработке надежных и согласованных распределенных систем с использованием передовых архитектурных шаблонов. Поддерживая как модели Sagas, так и TCC, он предоставляет комплексную платформу для тестирования и улучшения микросервисных архитектур, что делает его весьма универсальным инструментом для разработчиков, работающих над распределенными приложениями.

Симулятор и эксперимент с системой Quizzes Tutor доступны в публичном репозитории.

# Ограничения системы и планы на будущее
Разработка симулятора микросервисов, несмотря на успешное достижение целей по симуляции распределенных систем с использованием архитектурного шаблона Saga, имеет определенные ограничения. Одним из наиболее заметных ограничений является зависимость от синхронного взаимодействия. Хотя асинхронное взаимодействие, типичное для реальных микросервисов, поддерживается симулятором, оценка в значительной степени опиралась на синхронные транзакции. Это создает пробел при попытке полностью симулировать среды, где микросервисы работают асинхронно, особенно при рассмотрении систем очередей сообщений, которые задерживают ответы или вносят сетевую задержку.

Еще одно ограничение заключается в том, что симулятор в настоящее время поддерживает координацию на основе оркестровки (orchestration-based coordination), что упрощает управление рабочим процессом за счет централизации контроля. Однако многие микросервисные системы предпочитают координацию на основе хореографии (choreography-based coordination), где сервисы управляют взаимодействиями независимо. Это расхождение с паттернами реального использования может привести к симуляции, которая не полностью отражает все нюансы взаимодействия, особенно в системах, которые подчеркивают высокую автономность сервисов.

Обработка компенсирующих транзакций также представляет собой проблему. Хотя симулятор включает компенсирующие действия для восстановления после сбоев, они в основном оркестрируются. Будущие улучшения должны распространить поддержку на гибридные модели, где не все транзакции полагаются на единый транзакционный шаблон. Это будет включать сценарии, в которых ACID-транзакции сосуществуют с моделями конечной согласованности на основе Saga, что лучше представляет более широкий спектр распределенных систем.

Кроме того, использование фреймворка представляет определенные трудности, особенно когда разработчикам необходимо определить зависимости между шагами в рамках функциональности. Эти зависимости часто включают использование семантических блокировок и механизмов связи на основе событий, которые предотвращают такие проблемы, как потерянные обновления и несогласованные чтения, но усложняют проектирование. Разработчики должны тщательно определять эти механизмы на основе бизнес-логики системы, что требует умеренного или высокого уровня знаний о системе. Однако потенциальным улучшением было бы расширение симулятора для автоматического расчета зависимостей между шагами в рамках функциональности. Анализируя вовлеченные события, блокировки и сервисы, симулятор мог бы предлагать или обеспечивать правильную последовательность действий, помогая разработчикам уменьшить количество ошибок и оптимизировать процесс реализации.

## Планы на будущее

Несколько улучшений могут устранить выявленные ограничения:

Улучшения асинхронной связи: Расширение оценки для включения шагов асинхронной связи позволит симулятору более точно отражать реальные очереди сообщений и отложенные ответы.

Координация на основе хореографии: Введение хореографии наряду с оркестровкой позволит разработчикам исследовать децентрализованные стратегии координации, обеспечивая большую гибкость при симуляции реальных систем.

Поддержка гибридных транзакционных моделей: Расширение симулятора для управления гибридными транзакционными средами, где некоторые сервисы используют строгие ACID-транзакции, в то время как другие полагаются на модели конечной согласованности, такие как Sagas.

Расчет зависимостей между шагами: Разработка функции в рамках симулятора, которая вычисляет зависимости между шагами в функциональности на основе семантических блокировок, событий и взаимодействий сервисов. Эта функция могла бы помочь автоматизировать обнаружение правильной последовательности шагов и предотвратить несогласованность во время разработки.

Интеграция с облачными средами: Добавление возможности симулировать микросервисы, работающие на распределенных облачных платформах, для обеспечения тестирования в более реалистичных распределенных условиях и предоставления информации о поведении облачных нативных систем.

Устранение этих областей позволит симулятору стать более мощным инструментом для проектирования и тестирования крупномасштабных, отказоустойчивых и эффективных систем на основе микросервисов.